"""A simple password generator that creates professional-sounding passwords.


import random
import string


def password_generator():
    # Password list (expand as needed)
    word_list = [
        # Cybersecurity / IT
        "network", "defence", "system", "threat", "forensic", "packet",
        "secure", "monitor", "alert", "shield", "intel", "response",
        "control", "access", "signal", "crypto", "guardian", "protocol",
        "firewall", "audit", "malware", "vulnerability", "exploit", "breach",
        "intrusion", "detection", "analysis", "cyber", "resilience", "backup",
        "recovery", "compliance", "governance", "encryption", "authentication",
        "honeypot", "log", "packetfilter", "endpoint", "malwareanalysis", "threatintel",
        "penetration", "exploitkit", "ransomware", "phishing", "botnet", "telemetry",
        "signalprocessing", "intrusiondetection", "vulnerabilityscan", "firewallrule",
        "packetcapture", "forensicanalysis", "cryptanalysis",

        # Programming / AI / Computer Science
        "cypher", "cipher", "algorithm", "binary", "byte", "kernel", "script", "daemon",
        "interface", "module", "function", "variable", "object", "class", "method",
        "array", "string", "integer", "float", "boolean", "loop", "condition", "exception",
        "algorithmic", "neural", "machinelearning", "deepfake",

        # Science / Physics / Astronomy
        "sunrise", "sunset", "horizon", "matrix", "quantum", "nexus",
        "lunar", "solar", "nova", "eclipse", "comet", "orbit", "stellar", "galaxy",
        "nebula", "cosmic", "astro", "meteor", "plasma", "photon", "vector",
        "interstellar", "blackhole", "supernova", "pulsar", "quasar", "darkmatter", "antimatter",
        "wormhole", "timewarp", "chronos", "zenith", "apex", "summit", "pinnacle", "vertex",
        "fusion", "fission", "particle", "proton", "neutron", "electron", "quark", "boson",
        "singularity", "relativity", "entropy", "entanglement", "magnetism", "gravity",
        "hologram", "biosphere", "genome", "molecule", "atom", "nucleus", "chemical",
        "reaction", "catalyst", "vectorize", "simulation", "circuit", "transistor",
        "quantumbit", "cryptography", "hash", "token", "optics", "spectroscopy",
        "radiowave", "satellite", "asteroid", "constellation", "supercluster", "darkenergy",
        "blackbody", "thermodynamics", "chaos", "turbulence", "plasmawave", "microgravity",
        "nanotech", "biomechanics", "robotics", "AI", "cyberdefense",

        # Nature
        "beach", "forest", "desert", "ocean", "mountain", "river", "valley", "island", "canyon",
        "cloud", "storm", "breeze", "shadow", "ember", "glow", "frost", "dawn", "twilight",
        "zephyr", "rain", "snow", "thunder", "lightning", "volcano", "waterfall", "cliff",
        "meadow", "prairie", "savanna", "tundra", "jungle", "grove", "marsh", "lagoon",
        "reef", "glacier", "cave", "spring", "cypress", "willow", "oak", "maple", "pine",
        "cedar", "lily", "rose", "daisy", "sunflower", "butterfly", "falcon", "eagle", "wolf",
        "bear", "fox", "deer", "hawk", "owl", "lion", "tiger", "elephant"
    ]

    # Ask user for number of words
    while True:
        try:
            num_words = int(input("How many words would you like? (2 or 3): "))
            if num_words in [2, 3]:
                break
            else:
                print("Please enter 2 or 3.")
        except ValueError:
            print("Invalid input. Please enter 2 or 3.")

    # Ask for separator
    while True:
        separator = input("Choose separator ('-' or '_'): ").strip()
        if separator in ['-', '_']:
            break
        else:
            print("Please choose '-' or '_'.")

    # Pick random words and capitalize some
    words = [random.choice(word_list) for _ in range(num_words)]
    words = [word.capitalize() if random.choice([True, False]) else word for word in words]
    base_password = separator.join(words)

    # Mapping for letter â†’ number substitution
    number_map = {'a': '4', 'e': '3', 'i': '1', 'o': '0', 's': '5', 't': '7'}

    # Choose 2 distinct letters in the password to convert to numbers
    letters_in_pw = [ch for ch in base_password if ch.lower() in number_map]
    letters_to_replace = random.sample(letters_in_pw, k=min(2, len(letters_in_pw)))

    for letter in letters_to_replace:
        base_password = base_password.replace(letter, number_map[letter.lower()], 1)

    # Choose 1 random alphabetic character to convert to a special symbol
    specials = "!@#$%^&*?"
    letters_only = [c for c in base_password if c.isalpha()]
    if letters_only:
        target = random.choice(letters_only)
        base_password = base_password.replace(target, random.choice(specials), 1)

    print("\nGenerated professional password:")
    print(base_password)


if __name__ == "__main__":
    password_generator()
"""


#!/usr/bin/env python3
import random
import os
from datetime import datetime

def password_generator():
    # --- word list (abbreviated) ---
    word_list = [
        "network", "defence", "system", "threat", "forensic", "packet",
        "secure", "monitor", "alert", "shield", "intel", "response",
        "control", "access", "signal", "crypto", "guardian", "protocol",
        "firewall", "audit", "malware", "vulnerability", "exploit", "breach",
        "AI", "cyberdefense"
    ]

    # Ask number of words
    while True:
        try:
            num_words = int(input("How many words would you like? (2 or 3): ").strip())
            if num_words in [2,3]:
                break
            print("Please enter 2 or 3.")
        except ValueError:
            print("Invalid input. Please enter 2 or 3.")

    # Separator
    while True:
        separator = input("Choose separator ('-' or '_'): ").strip()
        if separator in ['-', '_']:
            break
        print("Please choose '-' or '_'.")

    # Generate password
    words = [random.choice(word_list) for _ in range(num_words)]
    words = [w.capitalize() if random.choice([True, False]) else w for w in words]
    base_password = separator.join(words)

    number_map = {'a':'4','e':'3','i':'1','o':'0','s':'5','t':'7'}
    letters_in_pw = [ch for ch in base_password if ch.lower() in number_map]
    if letters_in_pw:
        letters_to_replace = random.sample(letters_in_pw, k=min(2,len(letters_in_pw)))
        for letter in letters_to_replace:
            base_password = base_password.replace(letter, number_map[letter.lower()], 1)

    specials = "!@#$%^&*?"
    letters_only = [c for c in base_password if c.isalpha()]
    if letters_only:
        target = random.choice(letters_only)
        base_password = base_password.replace(target, random.choice(specials), 1)

    print("\nGenerated professional password:")
    print(base_password)

    # Zone / network
    zone = input("\nEnter zone/network (e.g., DMZ, Workstations, Servers, etc.): ").strip()

    # Domain/IP
    domain_or_ip = input("\nEnter domain name or IP to map this password: ").strip()

    # Folder to save
    folder = input("\nEnter folder path to save passwords (press Enter for home folder): ").strip()
    if not folder:
        folder = os.path.expanduser("~")
    os.makedirs(folder, exist_ok=True)
    pw_file = os.path.join(folder, "passwords.txt")

    # Column widths
    ts_width = 20
    domain_width = 30
    password_width = 30
    header_line = f"{'Timestamp'.ljust(ts_width)} | {'Domain/IP'.ljust(domain_width)} | {'Password'.ljust(password_width)}\n"

    # Read existing entries grouped by zone
    zones = {}
    if os.path.exists(pw_file):
        with open(pw_file, "r", encoding="utf-8") as f:
            lines = f.readlines()
        current_zone = None
        for line in lines:
            line = line.strip()
            if line.startswith("===") and line.endswith("==="):
                current_zone = line.strip("= ").strip()
                zones.setdefault(current_zone, {})
            elif 'Domain/IP' in line or line == '':
                continue
            else:
                if current_zone:
                    parts = [p.strip() for p in line.split('|')]
                    if len(parts) == 3:
                        zones[current_zone][parts[1]] = (parts[0], parts[2])  # key = domain/IP

    # Update or add entry for this zone
    timestamp = datetime.now().isoformat(timespec='seconds')
    zones.setdefault(zone, {})
    zones[zone][domain_or_ip] = (timestamp, base_password)

    # Write back all zones sorted by zone name
    try:
        with open(pw_file, "w", encoding="utf-8") as f:
            for z in sorted(zones.keys()):
                f.write(f"=== {z} ===\n")
                f.write(header_line)
                for domain in sorted(zones[z].keys()):
                    ts, pw = zones[z][domain]
                    line = f"{ts.ljust(ts_width)} | {domain.ljust(domain_width)} | {pw.ljust(password_width)}\n"
                    f.write(line)
                f.write("\n")  # blank line between zones
    except OSError as e:
        print(f"Error writing file: {e}")
        return

    print(f"\nSaved/Updated password in: {pw_file}")
    print(f"Entry: {timestamp} | {zone} | {domain_or_ip} | {base_password}")

if __name__ == "__main__":
    password_generator()




